(function(global, factory) {
    // Check for module or AMD (Asynchronous Module Definition) support
    if (typeof define === 'function' && define.amd) {
        define([], factory);  // Define the module using AMD
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();  // Export as CommonJS module
    } else {
        global.Rellax = factory();  // Attach to the global object if neither AMD nor CommonJS
    }
})(
    typeof window !== 'undefined' ? window : global, 
    function() {
        // Initialize the core function
        var Rellax = function(elementSelector, options) {
            var instance = Object.create(Rellax.prototype);  // Create a new instance
            var breakpoints = [576, 768, 1201];  // Default breakpoints
            var elems = [];  // List of elements to apply the effect
            var transforms = [];  // Store the initial transforms of elements
            var isMobile = false;  // Flag to check if it's a mobile device

            // Helper function to check and set breakpoints
            function checkBreakpoints() {
                if (Array.isArray(options.breakpoints) && options.breakpoints.length === 3) {
                    breakpoints = options.breakpoints;
                } else {
                    console.warn('Invalid breakpoints array. Reverting to default.');
                    options.breakpoints = [576, 768, 1201];
                }
            }

            // Merge custom options with default settings
            options = Object.assign({
                speed: -2,
                verticalSpeed: null,
                horizontalSpeed: null,
                breakpoints: [576, 768, 1201],
                center: false,
                wrapper: null,
                relativeToWrapper: false,
                round: true,
                vertical: true,
                horizontal: false,
                verticalScrollAxis: 'y',
                horizontalScrollAxis: 'x',
                callback: function() {}
            }, options);

            // Apply breakpoints check
            if (options.breakpoints) checkBreakpoints();

            // Select elements based on the provided selector
            elems = (typeof elementSelector === 'string') ? document.querySelectorAll(elementSelector) : [elementSelector];

            // If wrapper option is provided, handle it
            if (options.wrapper && options.wrapper.nodeType) {
                options.wrapper = document.querySelector(options.wrapper);
            } else if (options.wrapper) {
                console.warn('Wrapper not found.');
                return;
            }

            // Update the state of the elements based on scroll position and window size
            var updateState = function() {
                for (var i = 0; i < elems.length; i++) {
                    var elem = elems[i];
                    var percentage = elem.getAttribute('data-rellax-percentage');
                    var speed = elem.getAttribute('data-rellax-speed') || options.speed;
                    var verticalSpeed = elem.getAttribute('data-rellax-vertical-speed');
                    var horizontalSpeed = elem.getAttribute('data-rellax-horizontal-speed');
                    var scrollTop = options.wrapper ? options.wrapper.scrollTop : window.pageYOffset;

                    var elemRect = elem.getBoundingClientRect();
                    var offsetTop = elemRect.top + scrollTop;
                    var offsetLeft = elemRect.left + window.pageXOffset;
                    var height = elem.offsetHeight;
                    var width = elem.offsetWidth;
                    var verticalScroll = options.vertical ? (scrollTop + window.innerHeight - offsetTop) / (height + window.innerHeight) : 0;
                    var horizontalScroll = options.horizontal ? (window.pageXOffset + window.innerWidth - offsetLeft) / (width + window.innerWidth) : 0;

                    // Calculate the movement for this element
                    var x = (horizontalScroll || 0) * (horizontalSpeed || speed);
                    var y = (verticalScroll || 0) * (verticalSpeed || speed);

                    elem.style.transform = `translate3d(${x}px, ${y}px, 0)`;

                    // Store the initial style of the element to revert it later
                    transforms.push({
                        baseX: x,
                        baseY: y,
                        top: offsetTop,
                        left: offsetLeft,
                        height: height,
                        width: width,
                        speed: speed,
                        verticalSpeed: verticalSpeed,
                        horizontalSpeed: horizontalSpeed,
                        transform: elem.style.cssText
                    });
                }
            };

            // Add event listeners for window resize and scroll
            window.addEventListener('resize', updateState);
            window.addEventListener('scroll', updateState);

            // Function to destroy and clean up the instance
            instance.destroy = function() {
                for (var i = 0; i < elems.length; i++) {
                    elems[i].style.cssText = transforms[i].transform;
                }
                window.removeEventListener('resize', updateState);
                window.removeEventListener('scroll', updateState);
            };

            // Return the instance with methods to refresh or destroy
            instance.refresh = updateState;

            // Initialize the state immediately
            updateState();

            return instance;
        };

        return Rellax;  // Return the main function
    }
);